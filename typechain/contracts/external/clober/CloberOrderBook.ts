/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export type OrderKeyStruct = {
  isBid: PromiseOrValue<boolean>;
  priceIndex: PromiseOrValue<BigNumberish>;
  orderIndex: PromiseOrValue<BigNumberish>;
};

export type OrderKeyStructOutput = [boolean, number, BigNumber] & {
  isBid: boolean;
  priceIndex: number;
  orderIndex: BigNumber;
};

export declare namespace CloberOrderBook {
  export type BlockTradeLogStruct = {
    blockTime: PromiseOrValue<BigNumberish>;
    askVolume: PromiseOrValue<BigNumberish>;
    bidVolume: PromiseOrValue<BigNumberish>;
    open: PromiseOrValue<BigNumberish>;
    high: PromiseOrValue<BigNumberish>;
    low: PromiseOrValue<BigNumberish>;
    close: PromiseOrValue<BigNumberish>;
  };

  export type BlockTradeLogStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    number
  ] & {
    blockTime: BigNumber;
    askVolume: BigNumber;
    bidVolume: BigNumber;
    open: number;
    high: number;
    low: number;
    close: number;
  };

  export type OrderStruct = {
    amount: PromiseOrValue<BigNumberish>;
    claimBounty: PromiseOrValue<BigNumberish>;
    owner: PromiseOrValue<string>;
  };

  export type OrderStructOutput = [BigNumber, number, string] & {
    amount: BigNumber;
    claimBounty: number;
    owner: string;
  };
}

export interface CloberOrderBookInterface extends utils.Interface {
  functions: {
    "baseToRaw(uint256,uint16,bool)": FunctionFragment;
    "baseToken()": FunctionFragment;
    "bestPriceIndex(bool)": FunctionFragment;
    "blockTradeLogIndex()": FunctionFragment;
    "blockTradeLogs(uint16)": FunctionFragment;
    "cancel(address,(bool,uint16,uint256)[])": FunctionFragment;
    "changeOrderOwner((bool,uint16,uint256),address)": FunctionFragment;
    "claim(address,(bool,uint16,uint256)[])": FunctionFragment;
    "collectFees(address,address)": FunctionFragment;
    "flash(address,uint256,uint256,bytes)": FunctionFragment;
    "getClaimable((bool,uint16,uint256))": FunctionFragment;
    "getDepth(bool,uint16)": FunctionFragment;
    "getExpectedAmount(uint16,uint64,uint256,uint8)": FunctionFragment;
    "getFeeBalance()": FunctionFragment;
    "getOrder((bool,uint16,uint256))": FunctionFragment;
    "indexToPrice(uint16)": FunctionFragment;
    "isEmpty(bool)": FunctionFragment;
    "limitOrder(address,uint16,uint64,uint256,uint8,bytes)": FunctionFragment;
    "makerFee()": FunctionFragment;
    "marketOrder(address,uint16,uint64,uint256,uint8,bytes)": FunctionFragment;
    "orderToken()": FunctionFragment;
    "priceToIndex(uint256,bool)": FunctionFragment;
    "quoteToRaw(uint256,bool)": FunctionFragment;
    "quoteToken()": FunctionFragment;
    "quoteUnit()": FunctionFragment;
    "rawToBase(uint64,uint16,bool)": FunctionFragment;
    "rawToQuote(uint64)": FunctionFragment;
    "takerFee()": FunctionFragment;
    "uncollectedHostFees(address)": FunctionFragment;
    "uncollectedProtocolFees(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "baseToRaw"
      | "baseToken"
      | "bestPriceIndex"
      | "blockTradeLogIndex"
      | "blockTradeLogs"
      | "cancel"
      | "changeOrderOwner"
      | "claim"
      | "collectFees"
      | "flash"
      | "getClaimable"
      | "getDepth"
      | "getExpectedAmount"
      | "getFeeBalance"
      | "getOrder"
      | "indexToPrice"
      | "isEmpty"
      | "limitOrder"
      | "makerFee"
      | "marketOrder"
      | "orderToken"
      | "priceToIndex"
      | "quoteToRaw"
      | "quoteToken"
      | "quoteUnit"
      | "rawToBase"
      | "rawToQuote"
      | "takerFee"
      | "uncollectedHostFees"
      | "uncollectedProtocolFees"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "baseToRaw",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(functionFragment: "baseToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "bestPriceIndex",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "blockTradeLogIndex",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "blockTradeLogs",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancel",
    values: [PromiseOrValue<string>, OrderKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "changeOrderOwner",
    values: [OrderKeyStruct, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "claim",
    values: [PromiseOrValue<string>, OrderKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "collectFees",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "flash",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getClaimable",
    values: [OrderKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getDepth",
    values: [PromiseOrValue<boolean>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getExpectedAmount",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getFeeBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOrder",
    values: [OrderKeyStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "indexToPrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isEmpty",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "limitOrder",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "makerFee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "marketOrder",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "orderToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceToIndex",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "quoteToRaw",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "quoteToken",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "quoteUnit", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rawToBase",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rawToQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "takerFee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "uncollectedHostFees",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "uncollectedProtocolFees",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: "baseToRaw", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "baseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "bestPriceIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "blockTradeLogIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "blockTradeLogs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeOrderOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "collectFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "flash", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getClaimable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDepth", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getExpectedAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFeeBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "indexToPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isEmpty", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "limitOrder", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "makerFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "orderToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceToIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "quoteToRaw", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "quoteToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "quoteUnit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rawToBase", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rawToQuote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "takerFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "uncollectedHostFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uncollectedProtocolFees",
    data: BytesLike
  ): Result;

  events: {
    "CancelOrder(address,uint64,uint256,uint16,bool)": EventFragment;
    "ClaimOrder(address,address,uint64,uint256,uint256,uint16,bool)": EventFragment;
    "Flash(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "MakeOrder(address,address,uint64,uint32,uint256,uint16,uint8)": EventFragment;
    "TakeOrder(address,address,uint16,uint64,uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CancelOrder"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ClaimOrder"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Flash"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MakeOrder"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TakeOrder"): EventFragment;
}

export interface CancelOrderEventObject {
  user: string;
  rawAmount: BigNumber;
  orderIndex: BigNumber;
  priceIndex: number;
  isBid: boolean;
}
export type CancelOrderEvent = TypedEvent<
  [string, BigNumber, BigNumber, number, boolean],
  CancelOrderEventObject
>;

export type CancelOrderEventFilter = TypedEventFilter<CancelOrderEvent>;

export interface ClaimOrderEventObject {
  claimer: string;
  user: string;
  rawAmount: BigNumber;
  bountyAmount: BigNumber;
  orderIndex: BigNumber;
  priceIndex: number;
  isBase: boolean;
}
export type ClaimOrderEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, number, boolean],
  ClaimOrderEventObject
>;

export type ClaimOrderEventFilter = TypedEventFilter<ClaimOrderEvent>;

export interface FlashEventObject {
  caller: string;
  borrower: string;
  quoteAmount: BigNumber;
  baseAmount: BigNumber;
  earnedQuote: BigNumber;
  earnedBase: BigNumber;
}
export type FlashEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  FlashEventObject
>;

export type FlashEventFilter = TypedEventFilter<FlashEvent>;

export interface MakeOrderEventObject {
  sender: string;
  user: string;
  rawAmount: BigNumber;
  claimBounty: number;
  orderIndex: BigNumber;
  priceIndex: number;
  options: number;
}
export type MakeOrderEvent = TypedEvent<
  [string, string, BigNumber, number, BigNumber, number, number],
  MakeOrderEventObject
>;

export type MakeOrderEventFilter = TypedEventFilter<MakeOrderEvent>;

export interface TakeOrderEventObject {
  sender: string;
  user: string;
  priceIndex: number;
  rawAmount: BigNumber;
  options: number;
}
export type TakeOrderEvent = TypedEvent<
  [string, string, number, BigNumber, number],
  TakeOrderEventObject
>;

export type TakeOrderEventFilter = TypedEventFilter<TakeOrderEvent>;

export interface CloberOrderBook extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CloberOrderBookInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    baseToRaw(
      baseAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    baseToken(overrides?: CallOverrides): Promise<[string]>;

    bestPriceIndex(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    blockTradeLogIndex(overrides?: CallOverrides): Promise<[number]>;

    blockTradeLogs(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[CloberOrderBook.BlockTradeLogStructOutput]>;

    cancel(
      receiver: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeOrderOwner(
      orderKey: OrderKeyStruct,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claim(
      claimer: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    collectFees(
      token: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    flash(
      borrower: PromiseOrValue<string>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getClaimable(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        claimableRawAmount: BigNumber;
        claimableAmount: BigNumber;
        feeAmount: BigNumber;
        rebateAmount: BigNumber;
      }
    >;

    getDepth(
      isBid: PromiseOrValue<boolean>,
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getExpectedAmount(
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getFeeBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { quote: BigNumber; base: BigNumber }>;

    getOrder(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<[CloberOrderBook.OrderStructOutput]>;

    indexToPrice(
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    isEmpty(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    limitOrder(
      user: PromiseOrValue<string>,
      priceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    makerFee(overrides?: CallOverrides): Promise<[number]>;

    marketOrder(
      user: PromiseOrValue<string>,
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    orderToken(overrides?: CallOverrides): Promise<[string]>;

    priceToIndex(
      price: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber] & { index: number; correctedPrice: BigNumber }
    >;

    quoteToRaw(
      quoteAmount: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    quoteToken(overrides?: CallOverrides): Promise<[string]>;

    quoteUnit(overrides?: CallOverrides): Promise<[BigNumber]>;

    rawToBase(
      rawAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    rawToQuote(
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    takerFee(overrides?: CallOverrides): Promise<[number]>;

    uncollectedHostFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    uncollectedProtocolFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  baseToRaw(
    baseAmount: PromiseOrValue<BigNumberish>,
    priceIndex: PromiseOrValue<BigNumberish>,
    roundingUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  baseToken(overrides?: CallOverrides): Promise<string>;

  bestPriceIndex(
    isBid: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<number>;

  blockTradeLogIndex(overrides?: CallOverrides): Promise<number>;

  blockTradeLogs(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<CloberOrderBook.BlockTradeLogStructOutput>;

  cancel(
    receiver: PromiseOrValue<string>,
    orderKeys: OrderKeyStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeOrderOwner(
    orderKey: OrderKeyStruct,
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claim(
    claimer: PromiseOrValue<string>,
    orderKeys: OrderKeyStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  collectFees(
    token: PromiseOrValue<string>,
    destination: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  flash(
    borrower: PromiseOrValue<string>,
    quoteAmount: PromiseOrValue<BigNumberish>,
    baseAmount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getClaimable(
    orderKey: OrderKeyStruct,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      claimableRawAmount: BigNumber;
      claimableAmount: BigNumber;
      feeAmount: BigNumber;
      rebateAmount: BigNumber;
    }
  >;

  getDepth(
    isBid: PromiseOrValue<boolean>,
    priceIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getExpectedAmount(
    limitPriceIndex: PromiseOrValue<BigNumberish>,
    rawAmount: PromiseOrValue<BigNumberish>,
    baseAmount: PromiseOrValue<BigNumberish>,
    options: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getFeeBalance(
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { quote: BigNumber; base: BigNumber }>;

  getOrder(
    orderKey: OrderKeyStruct,
    overrides?: CallOverrides
  ): Promise<CloberOrderBook.OrderStructOutput>;

  indexToPrice(
    priceIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  isEmpty(
    isBid: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  limitOrder(
    user: PromiseOrValue<string>,
    priceIndex: PromiseOrValue<BigNumberish>,
    rawAmount: PromiseOrValue<BigNumberish>,
    baseAmount: PromiseOrValue<BigNumberish>,
    options: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  makerFee(overrides?: CallOverrides): Promise<number>;

  marketOrder(
    user: PromiseOrValue<string>,
    limitPriceIndex: PromiseOrValue<BigNumberish>,
    rawAmount: PromiseOrValue<BigNumberish>,
    baseAmount: PromiseOrValue<BigNumberish>,
    options: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  orderToken(overrides?: CallOverrides): Promise<string>;

  priceToIndex(
    price: PromiseOrValue<BigNumberish>,
    roundingUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber] & { index: number; correctedPrice: BigNumber }
  >;

  quoteToRaw(
    quoteAmount: PromiseOrValue<BigNumberish>,
    roundingUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  quoteToken(overrides?: CallOverrides): Promise<string>;

  quoteUnit(overrides?: CallOverrides): Promise<BigNumber>;

  rawToBase(
    rawAmount: PromiseOrValue<BigNumberish>,
    priceIndex: PromiseOrValue<BigNumberish>,
    roundingUp: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  rawToQuote(
    rawAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  takerFee(overrides?: CallOverrides): Promise<number>;

  uncollectedHostFees(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  uncollectedProtocolFees(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    baseToRaw(
      baseAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<string>;

    bestPriceIndex(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<number>;

    blockTradeLogIndex(overrides?: CallOverrides): Promise<number>;

    blockTradeLogs(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<CloberOrderBook.BlockTradeLogStructOutput>;

    cancel(
      receiver: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    changeOrderOwner(
      orderKey: OrderKeyStruct,
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    claim(
      claimer: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    collectFees(
      token: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    flash(
      borrower: PromiseOrValue<string>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    getClaimable(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        claimableRawAmount: BigNumber;
        claimableAmount: BigNumber;
        feeAmount: BigNumber;
        rebateAmount: BigNumber;
      }
    >;

    getDepth(
      isBid: PromiseOrValue<boolean>,
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getExpectedAmount(
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getFeeBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { quote: BigNumber; base: BigNumber }>;

    getOrder(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<CloberOrderBook.OrderStructOutput>;

    indexToPrice(
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isEmpty(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    limitOrder(
      user: PromiseOrValue<string>,
      priceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    makerFee(overrides?: CallOverrides): Promise<number>;

    marketOrder(
      user: PromiseOrValue<string>,
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    orderToken(overrides?: CallOverrides): Promise<string>;

    priceToIndex(
      price: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber] & { index: number; correctedPrice: BigNumber }
    >;

    quoteToRaw(
      quoteAmount: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    quoteToken(overrides?: CallOverrides): Promise<string>;

    quoteUnit(overrides?: CallOverrides): Promise<BigNumber>;

    rawToBase(
      rawAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rawToQuote(
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    takerFee(overrides?: CallOverrides): Promise<number>;

    uncollectedHostFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    uncollectedProtocolFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "CancelOrder(address,uint64,uint256,uint16,bool)"(
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      orderIndex?: null,
      priceIndex?: null,
      isBid?: null
    ): CancelOrderEventFilter;
    CancelOrder(
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      orderIndex?: null,
      priceIndex?: null,
      isBid?: null
    ): CancelOrderEventFilter;

    "ClaimOrder(address,address,uint64,uint256,uint256,uint16,bool)"(
      claimer?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      bountyAmount?: null,
      orderIndex?: null,
      priceIndex?: null,
      isBase?: null
    ): ClaimOrderEventFilter;
    ClaimOrder(
      claimer?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      bountyAmount?: null,
      orderIndex?: null,
      priceIndex?: null,
      isBase?: null
    ): ClaimOrderEventFilter;

    "Flash(address,address,uint256,uint256,uint256,uint256)"(
      caller?: PromiseOrValue<string> | null,
      borrower?: PromiseOrValue<string> | null,
      quoteAmount?: null,
      baseAmount?: null,
      earnedQuote?: null,
      earnedBase?: null
    ): FlashEventFilter;
    Flash(
      caller?: PromiseOrValue<string> | null,
      borrower?: PromiseOrValue<string> | null,
      quoteAmount?: null,
      baseAmount?: null,
      earnedQuote?: null,
      earnedBase?: null
    ): FlashEventFilter;

    "MakeOrder(address,address,uint64,uint32,uint256,uint16,uint8)"(
      sender?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      claimBounty?: null,
      orderIndex?: null,
      priceIndex?: null,
      options?: null
    ): MakeOrderEventFilter;
    MakeOrder(
      sender?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      rawAmount?: null,
      claimBounty?: null,
      orderIndex?: null,
      priceIndex?: null,
      options?: null
    ): MakeOrderEventFilter;

    "TakeOrder(address,address,uint16,uint64,uint8)"(
      sender?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      priceIndex?: null,
      rawAmount?: null,
      options?: null
    ): TakeOrderEventFilter;
    TakeOrder(
      sender?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      priceIndex?: null,
      rawAmount?: null,
      options?: null
    ): TakeOrderEventFilter;
  };

  estimateGas: {
    baseToRaw(
      baseAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<BigNumber>;

    bestPriceIndex(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    blockTradeLogIndex(overrides?: CallOverrides): Promise<BigNumber>;

    blockTradeLogs(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancel(
      receiver: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeOrderOwner(
      orderKey: OrderKeyStruct,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claim(
      claimer: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    collectFees(
      token: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    flash(
      borrower: PromiseOrValue<string>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getClaimable(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDepth(
      isBid: PromiseOrValue<boolean>,
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getExpectedAmount(
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFeeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getOrder(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    indexToPrice(
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isEmpty(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    limitOrder(
      user: PromiseOrValue<string>,
      priceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    makerFee(overrides?: CallOverrides): Promise<BigNumber>;

    marketOrder(
      user: PromiseOrValue<string>,
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    orderToken(overrides?: CallOverrides): Promise<BigNumber>;

    priceToIndex(
      price: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    quoteToRaw(
      quoteAmount: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    quoteToken(overrides?: CallOverrides): Promise<BigNumber>;

    quoteUnit(overrides?: CallOverrides): Promise<BigNumber>;

    rawToBase(
      rawAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rawToQuote(
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    takerFee(overrides?: CallOverrides): Promise<BigNumber>;

    uncollectedHostFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    uncollectedProtocolFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    baseToRaw(
      baseAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    baseToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bestPriceIndex(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    blockTradeLogIndex(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    blockTradeLogs(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancel(
      receiver: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeOrderOwner(
      orderKey: OrderKeyStruct,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claim(
      claimer: PromiseOrValue<string>,
      orderKeys: OrderKeyStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    collectFees(
      token: PromiseOrValue<string>,
      destination: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    flash(
      borrower: PromiseOrValue<string>,
      quoteAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getClaimable(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDepth(
      isBid: PromiseOrValue<boolean>,
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getExpectedAmount(
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFeeBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOrder(
      orderKey: OrderKeyStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    indexToPrice(
      priceIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isEmpty(
      isBid: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    limitOrder(
      user: PromiseOrValue<string>,
      priceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    makerFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketOrder(
      user: PromiseOrValue<string>,
      limitPriceIndex: PromiseOrValue<BigNumberish>,
      rawAmount: PromiseOrValue<BigNumberish>,
      baseAmount: PromiseOrValue<BigNumberish>,
      options: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    orderToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceToIndex(
      price: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    quoteToRaw(
      quoteAmount: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    quoteToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    quoteUnit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rawToBase(
      rawAmount: PromiseOrValue<BigNumberish>,
      priceIndex: PromiseOrValue<BigNumberish>,
      roundingUp: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rawToQuote(
      rawAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    takerFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    uncollectedHostFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    uncollectedProtocolFees(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
