schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Depth {
  id: ID!
  market: Market!
  priceIndex: BigInt!
  price: BigInt!
  isBid: Boolean!
  rawAmount: BigInt!
  baseAmount: BigInt!
}

input Depth_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  priceIndex: BigInt
  priceIndex_not: BigInt
  priceIndex_gt: BigInt
  priceIndex_lt: BigInt
  priceIndex_gte: BigInt
  priceIndex_lte: BigInt
  priceIndex_in: [BigInt!]
  priceIndex_not_in: [BigInt!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  isBid: Boolean
  isBid_not: Boolean
  isBid_in: [Boolean!]
  isBid_not_in: [Boolean!]
  rawAmount: BigInt
  rawAmount_not: BigInt
  rawAmount_gt: BigInt
  rawAmount_lt: BigInt
  rawAmount_gte: BigInt
  rawAmount_lte: BigInt
  rawAmount_in: [BigInt!]
  rawAmount_not_in: [BigInt!]
  baseAmount: BigInt
  baseAmount_not: BigInt
  baseAmount_gt: BigInt
  baseAmount_lt: BigInt
  baseAmount_gte: BigInt
  baseAmount_lte: BigInt
  baseAmount_in: [BigInt!]
  baseAmount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Depth_filter]
  or: [Depth_filter]
}

enum Depth_orderBy {
  id
  market
  market__id
  market__orderToken
  market__quoteUnit
  market__makerFee
  market__takerFee
  market__a
  market__r
  market__d
  priceIndex
  price
  isBid
  rawAmount
  baseAmount
}

"""
8 bytes signed integer

"""
scalar Int8

type Market {
  id: ID!
  orderToken: Bytes!
  quoteToken: Token!
  baseToken: Token!
  quoteUnit: BigInt!
  makerFee: BigInt!
  takerFee: BigInt!
  a: BigInt!
  r: BigInt!
  d: BigInt!
  depths(skip: Int = 0, first: Int = 100, orderBy: Depth_orderBy, orderDirection: OrderDirection, where: Depth_filter): [Depth!]!
}

input Market_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  orderToken: Bytes
  orderToken_not: Bytes
  orderToken_gt: Bytes
  orderToken_lt: Bytes
  orderToken_gte: Bytes
  orderToken_lte: Bytes
  orderToken_in: [Bytes!]
  orderToken_not_in: [Bytes!]
  orderToken_contains: Bytes
  orderToken_not_contains: Bytes
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_: Token_filter
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_: Token_filter
  quoteUnit: BigInt
  quoteUnit_not: BigInt
  quoteUnit_gt: BigInt
  quoteUnit_lt: BigInt
  quoteUnit_gte: BigInt
  quoteUnit_lte: BigInt
  quoteUnit_in: [BigInt!]
  quoteUnit_not_in: [BigInt!]
  makerFee: BigInt
  makerFee_not: BigInt
  makerFee_gt: BigInt
  makerFee_lt: BigInt
  makerFee_gte: BigInt
  makerFee_lte: BigInt
  makerFee_in: [BigInt!]
  makerFee_not_in: [BigInt!]
  takerFee: BigInt
  takerFee_not: BigInt
  takerFee_gt: BigInt
  takerFee_lt: BigInt
  takerFee_gte: BigInt
  takerFee_lte: BigInt
  takerFee_in: [BigInt!]
  takerFee_not_in: [BigInt!]
  a: BigInt
  a_not: BigInt
  a_gt: BigInt
  a_lt: BigInt
  a_gte: BigInt
  a_lte: BigInt
  a_in: [BigInt!]
  a_not_in: [BigInt!]
  r: BigInt
  r_not: BigInt
  r_gt: BigInt
  r_lt: BigInt
  r_gte: BigInt
  r_lte: BigInt
  r_in: [BigInt!]
  r_not_in: [BigInt!]
  d: BigInt
  d_not: BigInt
  d_gt: BigInt
  d_lt: BigInt
  d_gte: BigInt
  d_lte: BigInt
  d_in: [BigInt!]
  d_not_in: [BigInt!]
  depths_: Depth_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Market_filter]
  or: [Market_filter]
}

enum Market_orderBy {
  id
  orderToken
  quoteToken
  quoteToken__id
  quoteToken__symbol
  quoteToken__name
  quoteToken__decimals
  baseToken
  baseToken__id
  baseToken__symbol
  baseToken__name
  baseToken__decimals
  quoteUnit
  makerFee
  takerFee
  a
  r
  d
  depths
}

type Order {
  id: ID!
  market: Market!
  user: Bytes!
  orderIndex: BigInt!
  isBid: Boolean!
  price: BigInt!
  priceIndex: BigInt!
  rawAmount: BigInt!
  amount: BigInt!
  rawOpenAmount: BigInt!
  openAmount: BigInt!
  rawFilledAmount: BigInt!
  filledAmount: BigInt!
  rawClaimableAmount: BigInt!
  claimableAmount: BigInt!
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

input Order_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  market: String
  market_not: String
  market_gt: String
  market_lt: String
  market_gte: String
  market_lte: String
  market_in: [String!]
  market_not_in: [String!]
  market_contains: String
  market_contains_nocase: String
  market_not_contains: String
  market_not_contains_nocase: String
  market_starts_with: String
  market_starts_with_nocase: String
  market_not_starts_with: String
  market_not_starts_with_nocase: String
  market_ends_with: String
  market_ends_with_nocase: String
  market_not_ends_with: String
  market_not_ends_with_nocase: String
  market_: Market_filter
  user: Bytes
  user_not: Bytes
  user_gt: Bytes
  user_lt: Bytes
  user_gte: Bytes
  user_lte: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  orderIndex: BigInt
  orderIndex_not: BigInt
  orderIndex_gt: BigInt
  orderIndex_lt: BigInt
  orderIndex_gte: BigInt
  orderIndex_lte: BigInt
  orderIndex_in: [BigInt!]
  orderIndex_not_in: [BigInt!]
  isBid: Boolean
  isBid_not: Boolean
  isBid_in: [Boolean!]
  isBid_not_in: [Boolean!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  priceIndex: BigInt
  priceIndex_not: BigInt
  priceIndex_gt: BigInt
  priceIndex_lt: BigInt
  priceIndex_gte: BigInt
  priceIndex_lte: BigInt
  priceIndex_in: [BigInt!]
  priceIndex_not_in: [BigInt!]
  rawAmount: BigInt
  rawAmount_not: BigInt
  rawAmount_gt: BigInt
  rawAmount_lt: BigInt
  rawAmount_gte: BigInt
  rawAmount_lte: BigInt
  rawAmount_in: [BigInt!]
  rawAmount_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  rawOpenAmount: BigInt
  rawOpenAmount_not: BigInt
  rawOpenAmount_gt: BigInt
  rawOpenAmount_lt: BigInt
  rawOpenAmount_gte: BigInt
  rawOpenAmount_lte: BigInt
  rawOpenAmount_in: [BigInt!]
  rawOpenAmount_not_in: [BigInt!]
  openAmount: BigInt
  openAmount_not: BigInt
  openAmount_gt: BigInt
  openAmount_lt: BigInt
  openAmount_gte: BigInt
  openAmount_lte: BigInt
  openAmount_in: [BigInt!]
  openAmount_not_in: [BigInt!]
  rawFilledAmount: BigInt
  rawFilledAmount_not: BigInt
  rawFilledAmount_gt: BigInt
  rawFilledAmount_lt: BigInt
  rawFilledAmount_gte: BigInt
  rawFilledAmount_lte: BigInt
  rawFilledAmount_in: [BigInt!]
  rawFilledAmount_not_in: [BigInt!]
  filledAmount: BigInt
  filledAmount_not: BigInt
  filledAmount_gt: BigInt
  filledAmount_lt: BigInt
  filledAmount_gte: BigInt
  filledAmount_lte: BigInt
  filledAmount_in: [BigInt!]
  filledAmount_not_in: [BigInt!]
  rawClaimableAmount: BigInt
  rawClaimableAmount_not: BigInt
  rawClaimableAmount_gt: BigInt
  rawClaimableAmount_lt: BigInt
  rawClaimableAmount_gte: BigInt
  rawClaimableAmount_lte: BigInt
  rawClaimableAmount_in: [BigInt!]
  rawClaimableAmount_not_in: [BigInt!]
  claimableAmount: BigInt
  claimableAmount_not: BigInt
  claimableAmount_gt: BigInt
  claimableAmount_lt: BigInt
  claimableAmount_gte: BigInt
  claimableAmount_lte: BigInt
  claimableAmount_in: [BigInt!]
  claimableAmount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Order_filter]
  or: [Order_filter]
}

enum Order_orderBy {
  id
  market
  market__id
  market__orderToken
  market__quoteUnit
  market__makerFee
  market__takerFee
  market__a
  market__r
  market__d
  user
  orderIndex
  isBid
  price
  priceIndex
  rawAmount
  amount
  rawOpenAmount
  openAmount
  rawFilledAmount
  filledAmount
  rawClaimableAmount
  claimableAmount
}

type Query {
  market(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  depth(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Depth
  depths(
    skip: Int = 0
    first: Int = 100
    orderBy: Depth_orderBy
    orderDirection: OrderDirection
    where: Depth_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Depth!]!
  order(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  market(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Market
  markets(
    skip: Int = 0
    first: Int = 100
    orderBy: Market_orderBy
    orderDirection: OrderDirection
    where: Market_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Market!]!
  depth(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Depth
  depths(
    skip: Int = 0
    first: Int = 100
    orderBy: Depth_orderBy
    orderDirection: OrderDirection
    where: Depth_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Depth!]!
  order(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orders(
    skip: Int = 0
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    where: Order_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Order!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: ID!
  symbol: String!
  name: String!
  decimals: BigInt!
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  symbol
  name
  decimals
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}