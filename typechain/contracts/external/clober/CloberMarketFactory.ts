/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace CloberMarketFactory {
  export type MarketInfoStruct = {
    host: PromiseOrValue<string>;
    marketType: PromiseOrValue<BigNumberish>;
    a: PromiseOrValue<BigNumberish>;
    factor: PromiseOrValue<BigNumberish>;
    futureHost: PromiseOrValue<string>;
  };

  export type MarketInfoStructOutput = [
    string,
    number,
    BigNumber,
    BigNumber,
    string
  ] & {
    host: string;
    marketType: number;
    a: BigNumber;
    factor: BigNumber;
    futureHost: string;
  };
}

export interface CloberMarketFactoryInterface extends utils.Interface {
  functions: {
    "canceler()": FunctionFragment;
    "changeDaoTreasury(address)": FunctionFragment;
    "createStableMarket(address,address,address,uint96,int24,uint24,uint128,uint128)": FunctionFragment;
    "createVolatileMarket(address,address,address,uint96,int24,uint24,uint128,uint128)": FunctionFragment;
    "daoTreasury()": FunctionFragment;
    "deployedArithmeticPriceBook(uint128,uint128)": FunctionFragment;
    "deployedGeometricPriceBook(uint128,uint128)": FunctionFragment;
    "executeChangeOwner()": FunctionFragment;
    "executeHandOverHost(address)": FunctionFragment;
    "formatOrderTokenName(address,address,uint256)": FunctionFragment;
    "formatOrderTokenSymbol(address,address,uint256)": FunctionFragment;
    "futureOwner()": FunctionFragment;
    "getMarketHost(address)": FunctionFragment;
    "getMarketInfo(address)": FunctionFragment;
    "marketDeployer()": FunctionFragment;
    "nonce()": FunctionFragment;
    "orderTokenDeployer()": FunctionFragment;
    "owner()": FunctionFragment;
    "prepareChangeOwner(address)": FunctionFragment;
    "prepareHandOverHost(address,address)": FunctionFragment;
    "priceBookDeployer()": FunctionFragment;
    "registerQuoteToken(address)": FunctionFragment;
    "registeredQuoteTokens(address)": FunctionFragment;
    "unregisterQuoteToken(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "canceler"
      | "changeDaoTreasury"
      | "createStableMarket"
      | "createVolatileMarket"
      | "daoTreasury"
      | "deployedArithmeticPriceBook"
      | "deployedGeometricPriceBook"
      | "executeChangeOwner"
      | "executeHandOverHost"
      | "formatOrderTokenName"
      | "formatOrderTokenSymbol"
      | "futureOwner"
      | "getMarketHost"
      | "getMarketInfo"
      | "marketDeployer"
      | "nonce"
      | "orderTokenDeployer"
      | "owner"
      | "prepareChangeOwner"
      | "prepareHandOverHost"
      | "priceBookDeployer"
      | "registerQuoteToken"
      | "registeredQuoteTokens"
      | "unregisterQuoteToken"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "canceler", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "changeDaoTreasury",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createStableMarket",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createVolatileMarket",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "daoTreasury",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployedArithmeticPriceBook",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deployedGeometricPriceBook",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeChangeOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeHandOverHost",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "formatOrderTokenName",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "formatOrderTokenSymbol",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "futureOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketHost",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "nonce", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "orderTokenDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "prepareChangeOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "prepareHandOverHost",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "priceBookDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "registerQuoteToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registeredQuoteTokens",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unregisterQuoteToken",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: "canceler", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeDaoTreasury",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createStableMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createVolatileMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "daoTreasury",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployedArithmeticPriceBook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployedGeometricPriceBook",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeChangeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHandOverHost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "formatOrderTokenName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "formatOrderTokenSymbol",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "futureOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMarketHost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMarketInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "orderTokenDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "prepareChangeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prepareHandOverHost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceBookDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerQuoteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registeredQuoteTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unregisterQuoteToken",
    data: BytesLike
  ): Result;

  events: {
    "ChangeDaoTreasury(address,address)": EventFragment;
    "ChangeHost(address,address,address)": EventFragment;
    "ChangeOwner(address,address)": EventFragment;
    "CreateStableMarket(address,address,address,address,uint256,uint256,int24,uint24,uint128,uint128)": EventFragment;
    "CreateVolatileMarket(address,address,address,address,uint256,uint256,int24,uint24,uint128,uint128)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ChangeDaoTreasury"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChangeHost"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChangeOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreateStableMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreateVolatileMarket"): EventFragment;
}

export interface ChangeDaoTreasuryEventObject {
  previousTreasury: string;
  newTreasury: string;
}
export type ChangeDaoTreasuryEvent = TypedEvent<
  [string, string],
  ChangeDaoTreasuryEventObject
>;

export type ChangeDaoTreasuryEventFilter =
  TypedEventFilter<ChangeDaoTreasuryEvent>;

export interface ChangeHostEventObject {
  market: string;
  previousHost: string;
  newHost: string;
}
export type ChangeHostEvent = TypedEvent<
  [string, string, string],
  ChangeHostEventObject
>;

export type ChangeHostEventFilter = TypedEventFilter<ChangeHostEvent>;

export interface ChangeOwnerEventObject {
  previousOwner: string;
  newOwner: string;
}
export type ChangeOwnerEvent = TypedEvent<
  [string, string],
  ChangeOwnerEventObject
>;

export type ChangeOwnerEventFilter = TypedEventFilter<ChangeOwnerEvent>;

export interface CreateStableMarketEventObject {
  market: string;
  orderToken: string;
  quoteToken: string;
  baseToken: string;
  quoteUnit: BigNumber;
  nonce: BigNumber;
  makerFee: number;
  takerFee: number;
  a: BigNumber;
  d: BigNumber;
}
export type CreateStableMarketEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    number,
    number,
    BigNumber,
    BigNumber
  ],
  CreateStableMarketEventObject
>;

export type CreateStableMarketEventFilter =
  TypedEventFilter<CreateStableMarketEvent>;

export interface CreateVolatileMarketEventObject {
  market: string;
  orderToken: string;
  quoteToken: string;
  baseToken: string;
  quoteUnit: BigNumber;
  nonce: BigNumber;
  makerFee: number;
  takerFee: number;
  a: BigNumber;
  r: BigNumber;
}
export type CreateVolatileMarketEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    number,
    number,
    BigNumber,
    BigNumber
  ],
  CreateVolatileMarketEventObject
>;

export type CreateVolatileMarketEventFilter =
  TypedEventFilter<CreateVolatileMarketEvent>;

export interface CloberMarketFactory extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CloberMarketFactoryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    canceler(overrides?: CallOverrides): Promise<[string]>;

    changeDaoTreasury(
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createStableMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createVolatileMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    daoTreasury(overrides?: CallOverrides): Promise<[string]>;

    deployedArithmeticPriceBook(
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    deployedGeometricPriceBook(
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    executeChangeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeHandOverHost(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    formatOrderTokenName(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    formatOrderTokenSymbol(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    futureOwner(overrides?: CallOverrides): Promise<[string]>;

    getMarketHost(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getMarketInfo(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [CloberMarketFactory.MarketInfoStructOutput] & {
        marketInfo: CloberMarketFactory.MarketInfoStructOutput;
      }
    >;

    marketDeployer(overrides?: CallOverrides): Promise<[string]>;

    nonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    orderTokenDeployer(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    prepareChangeOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    prepareHandOverHost(
      market: PromiseOrValue<string>,
      newHost: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    priceBookDeployer(overrides?: CallOverrides): Promise<[string]>;

    registerQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registeredQuoteTokens(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    unregisterQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  canceler(overrides?: CallOverrides): Promise<string>;

  changeDaoTreasury(
    treasury: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createStableMarket(
    host: PromiseOrValue<string>,
    quoteToken: PromiseOrValue<string>,
    baseToken: PromiseOrValue<string>,
    quoteUnit: PromiseOrValue<BigNumberish>,
    makerFee: PromiseOrValue<BigNumberish>,
    takerFee: PromiseOrValue<BigNumberish>,
    a: PromiseOrValue<BigNumberish>,
    d: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createVolatileMarket(
    host: PromiseOrValue<string>,
    quoteToken: PromiseOrValue<string>,
    baseToken: PromiseOrValue<string>,
    quoteUnit: PromiseOrValue<BigNumberish>,
    makerFee: PromiseOrValue<BigNumberish>,
    takerFee: PromiseOrValue<BigNumberish>,
    a: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  daoTreasury(overrides?: CallOverrides): Promise<string>;

  deployedArithmeticPriceBook(
    a: PromiseOrValue<BigNumberish>,
    d: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  deployedGeometricPriceBook(
    a: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  executeChangeOwner(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeHandOverHost(
    market: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  formatOrderTokenName(
    quoteToken: PromiseOrValue<string>,
    baseToken: PromiseOrValue<string>,
    marketNonce: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  formatOrderTokenSymbol(
    quoteToken: PromiseOrValue<string>,
    baseToken: PromiseOrValue<string>,
    marketNonce: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  futureOwner(overrides?: CallOverrides): Promise<string>;

  getMarketHost(
    market: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  getMarketInfo(
    market: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<CloberMarketFactory.MarketInfoStructOutput>;

  marketDeployer(overrides?: CallOverrides): Promise<string>;

  nonce(overrides?: CallOverrides): Promise<BigNumber>;

  orderTokenDeployer(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  prepareChangeOwner(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  prepareHandOverHost(
    market: PromiseOrValue<string>,
    newHost: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  priceBookDeployer(overrides?: CallOverrides): Promise<string>;

  registerQuoteToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registeredQuoteTokens(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  unregisterQuoteToken(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    canceler(overrides?: CallOverrides): Promise<string>;

    changeDaoTreasury(
      treasury: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createStableMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    createVolatileMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    daoTreasury(overrides?: CallOverrides): Promise<string>;

    deployedArithmeticPriceBook(
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    deployedGeometricPriceBook(
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    executeChangeOwner(overrides?: CallOverrides): Promise<void>;

    executeHandOverHost(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    formatOrderTokenName(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    formatOrderTokenSymbol(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    futureOwner(overrides?: CallOverrides): Promise<string>;

    getMarketHost(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    getMarketInfo(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<CloberMarketFactory.MarketInfoStructOutput>;

    marketDeployer(overrides?: CallOverrides): Promise<string>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    orderTokenDeployer(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    prepareChangeOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    prepareHandOverHost(
      market: PromiseOrValue<string>,
      newHost: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    priceBookDeployer(overrides?: CallOverrides): Promise<string>;

    registerQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    registeredQuoteTokens(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unregisterQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ChangeDaoTreasury(address,address)"(
      previousTreasury?: null,
      newTreasury?: null
    ): ChangeDaoTreasuryEventFilter;
    ChangeDaoTreasury(
      previousTreasury?: null,
      newTreasury?: null
    ): ChangeDaoTreasuryEventFilter;

    "ChangeHost(address,address,address)"(
      market?: PromiseOrValue<string> | null,
      previousHost?: null,
      newHost?: null
    ): ChangeHostEventFilter;
    ChangeHost(
      market?: PromiseOrValue<string> | null,
      previousHost?: null,
      newHost?: null
    ): ChangeHostEventFilter;

    "ChangeOwner(address,address)"(
      previousOwner?: null,
      newOwner?: null
    ): ChangeOwnerEventFilter;
    ChangeOwner(previousOwner?: null, newOwner?: null): ChangeOwnerEventFilter;

    "CreateStableMarket(address,address,address,address,uint256,uint256,int24,uint24,uint128,uint128)"(
      market?: PromiseOrValue<string> | null,
      orderToken?: null,
      quoteToken?: null,
      baseToken?: null,
      quoteUnit?: null,
      nonce?: null,
      makerFee?: null,
      takerFee?: null,
      a?: null,
      d?: null
    ): CreateStableMarketEventFilter;
    CreateStableMarket(
      market?: PromiseOrValue<string> | null,
      orderToken?: null,
      quoteToken?: null,
      baseToken?: null,
      quoteUnit?: null,
      nonce?: null,
      makerFee?: null,
      takerFee?: null,
      a?: null,
      d?: null
    ): CreateStableMarketEventFilter;

    "CreateVolatileMarket(address,address,address,address,uint256,uint256,int24,uint24,uint128,uint128)"(
      market?: PromiseOrValue<string> | null,
      orderToken?: null,
      quoteToken?: null,
      baseToken?: null,
      quoteUnit?: null,
      nonce?: null,
      makerFee?: null,
      takerFee?: null,
      a?: null,
      r?: null
    ): CreateVolatileMarketEventFilter;
    CreateVolatileMarket(
      market?: PromiseOrValue<string> | null,
      orderToken?: null,
      quoteToken?: null,
      baseToken?: null,
      quoteUnit?: null,
      nonce?: null,
      makerFee?: null,
      takerFee?: null,
      a?: null,
      r?: null
    ): CreateVolatileMarketEventFilter;
  };

  estimateGas: {
    canceler(overrides?: CallOverrides): Promise<BigNumber>;

    changeDaoTreasury(
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createStableMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createVolatileMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    daoTreasury(overrides?: CallOverrides): Promise<BigNumber>;

    deployedArithmeticPriceBook(
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deployedGeometricPriceBook(
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executeChangeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeHandOverHost(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    formatOrderTokenName(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    formatOrderTokenSymbol(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    futureOwner(overrides?: CallOverrides): Promise<BigNumber>;

    getMarketHost(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarketInfo(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketDeployer(overrides?: CallOverrides): Promise<BigNumber>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    orderTokenDeployer(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    prepareChangeOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    prepareHandOverHost(
      market: PromiseOrValue<string>,
      newHost: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    priceBookDeployer(overrides?: CallOverrides): Promise<BigNumber>;

    registerQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registeredQuoteTokens(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unregisterQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    canceler(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    changeDaoTreasury(
      treasury: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createStableMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createVolatileMarket(
      host: PromiseOrValue<string>,
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      quoteUnit: PromiseOrValue<BigNumberish>,
      makerFee: PromiseOrValue<BigNumberish>,
      takerFee: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    daoTreasury(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deployedArithmeticPriceBook(
      a: PromiseOrValue<BigNumberish>,
      d: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deployedGeometricPriceBook(
      a: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeChangeOwner(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeHandOverHost(
      market: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    formatOrderTokenName(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    formatOrderTokenSymbol(
      quoteToken: PromiseOrValue<string>,
      baseToken: PromiseOrValue<string>,
      marketNonce: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    futureOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMarketHost(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMarketInfo(
      market: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketDeployer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    orderTokenDeployer(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    prepareChangeOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    prepareHandOverHost(
      market: PromiseOrValue<string>,
      newHost: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    priceBookDeployer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    registerQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registeredQuoteTokens(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unregisterQuoteToken(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
